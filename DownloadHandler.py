import os
import queue
import string
import threading
import time
from concurrent.futures.thread import ThreadPoolExecutor
from uuid import uuid4

import pytube
from PyQt6.QtCore import QTimer
from PyQt6.QtWidgets import QWidget, QHBoxLayout, QLabel, QPushButton, QVBoxLayout, QListWidget
from pytube import YouTube, StreamQuery
from mutagen.easyid3 import EasyID3
from typing import NamedTuple, List

from AppDataHandler import DataHandler


class TagHandler:
    # Tag Label Constants
    TITLE = ("Title", "TIT2")
    ARTIST = ("Artist", "TPE1")
    ALBUM_ARTIST = ("AlbumArtist", "TPE2")
    ALBUM = ("Album", "TALB")
    YEAR = ("Year", "TYER")

    @classmethod
    def retrieve_metadata(cls, video: YouTube) -> dict:
        """Attempts to scrape metadata from YouTube generated descriptions."""
        text = video.description
        metadata = {}
        if text is not None:
            lines = text.split('\n')
        else:
            lines = [""]

        # Checks if the description was generated by YouTube.
        if lines[-1] == "Auto-generated by YouTube.":
            print("Description was auto generated.")
        else:
            metadata[cls.TITLE[0]] = video.title
            """
            if metadata[self.TITLE[0]] is tuple:
                # I have no idea why this happens, but apparently I need this.
                # This video in particular - https://youtu.be/hsklsxReSe0
                metadata[self.TITLE[0]] = metadata[self.TITLE[0]][0]
            """
            metadata[cls.ARTIST[0]] = video.author
            return metadata

        title, artist = lines[2].split(' · ', 1)
        album = lines[4]
        year = ""

        # Finds the release year if it exists.
        for line in lines:
            if line.find('Released on: ') != -1:
                year = line.split(': ')[1].split('-', 1)[0]
                break

        # If the release year wasn't found.
        if year == "":
            year = str(video.publish_date.date.year)

        # Make metadata dict.
        metadata[cls.TITLE[0]] = title
        metadata[cls.ARTIST[0]] = artist.replace(' · ', "; ")
        metadata[cls.ALBUM_ARTIST[0]] = artist.split(' · ')[0]
        metadata[cls.ALBUM[0]] = album
        if year != "":
            metadata[cls.YEAR[0]] = year

        print("Metadata: ", metadata)

        return metadata

    @classmethod
    def append_metadata(cls, file_path: str, metadata: dict):
        """
        Adds metadata to a mp3 file.
        :param file_path: Path of the mp3 file.
        :param metadata: The metadata to add.
        :return: None
        """
        # Docs: https://mutagen.readthedocs.io/en/latest/api/id3.html
        audio = EasyID3(file_path)

        # Register keys.
        audio.RegisterTextKey(cls.TITLE[0], cls.TITLE[1])
        audio.RegisterTextKey(cls.ARTIST[0], cls.ARTIST[1])
        audio.RegisterTextKey(cls.ALBUM_ARTIST[0], cls.ALBUM_ARTIST[1])
        audio.RegisterTextKey(cls.ALBUM[0], cls.ALBUM[1])
        audio.RegisterTextKey(cls.YEAR[0], cls.YEAR[1])

        # Append Metadata
        for key, value in metadata.items():
            audio[key] = value

        audio.save()


class DownloadRequest(NamedTuple):
    video_number: int
    video: YouTube
    audio_only: bool
    output_path: str


class ProcessRequest(NamedTuple):
    audio_file_to_process: str
    video_file_to_process: str
    output_file: str


class DownloadThreadArgs(NamedTuple):
    """
    :param output_path: The folder to download the file to.
    :param filename: The name of the file to use. (xyz.abc)
    :param video: The YouTube video to download.
    :param output_queue: Progress messages sent from the process.
    :param download_audio: Set true if downloading audio, otherwise it will download video.
    :param update_interval: How often to send progress information and check for messages. (milliseconds)
    """
    video: YouTube
    output_queue: queue
    download_audio: bool
    output_path: str
    filename: str
    update_interval: int = 100


class DownloadViewer(QWidget):
    # Characters that can't be in Windows directories.
    forbidden_chars = [
        ">",
        "<",
        ":",
        '"',
        "\\",
        "/",
        "|",
        "?",
        "*",
        "."
    ]

    @classmethod
    def convert_to_file_name(cls, name: str):
        cleaned_name = ""

        for char in name:
            if char not in cls.forbidden_chars:
                cleaned_name += char
            else:
                cleaned_name += " "

        return cleaned_name

    def __init__(self):
        super(DownloadViewer, self).__init__()

        print("Init download viewer.")
        self.output_queue = queue.Queue()
        self.stop_download_event = threading.Event()
        self.pause_download_event = threading.Event()
        self.message_check_timer = QTimer(self)
        self.message_check_timer.timeout.connect(self.check_for_messages)
        self.threads_finished = 0
        self.total_threads_to_finish = 0
        self.thread_pool: ThreadPoolExecutor = None

        # Top Bar
        top_bar = QHBoxLayout()
        self.return_button = QPushButton("Go Back")
        self.return_button.pressed.connect(self.on_go_back_pressed)
        self.stop_button = QPushButton("Stop")
        self.stop_button.pressed.connect(self.on_stop_pressed)
        top_bar.addWidget(QLabel("Downloads"))
        top_bar.addWidget(self.stop_button)
        top_bar.addWidget(self.return_button)

        self.download_list_view = QListWidget()

        layout = QVBoxLayout()
        layout.addLayout(top_bar)
        layout.addWidget(self.download_list_view)
        self.setLayout(layout)

    def on_stop_pressed(self):
        print("Stopping downloads.")
        self.stop_download_event.set()
        self.stop_button.setDisabled(True)

    def on_go_back_pressed(self):
        print("Going back.")

    def set_download_list(self, download_list: List[DownloadRequest]):
        print(f"Setting download list: {len(download_list)} items.")
        self.return_button.setDisabled(True)
        self.stop_button.setDisabled(False)

        self.pause_download_event.clear()
        self.stop_download_event.clear()
        self.message_check_timer.start(100)
        self.threads_finished = 0
        self.total_threads_to_finish = len(download_list)
        print(f"Total threads to complete: {self.total_threads_to_finish}")

        thread_count = DataHandler.get_config_file_info()[DataHandler.sim_download_key]
        audio_only = DataHandler.get_config_file_info()[DataHandler.audio_only_key]
        print(f"Using {thread_count} threads.\nAudio Only: {audio_only}")

        self.thread_pool = ThreadPoolExecutor(max_workers=thread_count)
        for request in download_list:
            self.thread_pool.submit(self.download_with_progress, DownloadThreadArgs(
                    request.video, self.output_queue, request.audio_only, request.output_path, f"{uuid4()}.mp4"))

    def check_for_messages(self):
        while not self.output_queue.empty():
            self.on_message_received(self.output_queue.get())

    def on_message_received(self, message: dict):
        print(f"Received message: {message}")

        if str.lower(message["type"]) == "update":
            if str.lower(message["value"]) == "thread finished":
                self.threads_finished += 1
                print(f"Current completed thread count: {self.threads_finished}")

                if self.threads_finished >= self.total_threads_to_finish:
                    self.return_button.setDisabled(False)
                    self.stop_button.setDisabled(True)
                    self.thread_pool.shutdown()
                    self.message_check_timer.stop()
                    print("Shutting down thread pool.")

    def download_with_progress(self, ars: DownloadThreadArgs) -> None:
        """
        Attempts to download a YouTube video with the ability to send progress reports and receive pause/cancel requests.
        :return: None
        """
        print(f"Beginning to download {ars.video.title}.")
        output_location = os.path.join(ars.output_path, ars.filename)
        ns_update_interval: int = ars.update_interval * 1000000
        is_paused = False
        canceled = False

        try:
            if ars.download_audio:
                stream = StreamQuery(ars.video.fmt_streams).get_audio_only()
            else:
                stream = StreamQuery(ars.video.fmt_streams).filter(
                    mime_type="video/mp4", adaptive=True).order_by("resolution").desc().first()

            with open(output_location, 'wb') as file:
                stream_chunks = pytube.streams.request.stream(stream.url)
                filesize: int = stream.filesize
                downloaded: int = 0
                time_of_last_queue_check: int = time.monotonic_ns()
                ars.output_queue.put({
                    "type": "update",
                    "value": "started"
                })

                print(f"Beginning download {ars.filename}.")
                while True:
                    # Send and receive messages.
                    if time.monotonic_ns() - time_of_last_queue_check > ns_update_interval:
                        time_of_last_queue_check = time.monotonic_ns()
                        is_paused = self.pause_download_event.is_set()

                        if self.stop_download_event.is_set():
                            canceled = True
                            break

                        ars.output_queue.put({
                            "type": "progress",
                            "value": int(downloaded / filesize * 100),
                            "video": ars.video
                        })

                    # Retrieve data.
                    if not is_paused:
                        chunk = next(stream_chunks, None)
                        if chunk:
                            file.write(chunk)
                            downloaded += len(chunk)
                        else:
                            ars.output_queue.put({
                                "type": "update",
                                "value": "completed"
                            })
                            break
                    else:
                        time.sleep(ars.update_interval / 1000)

        except Exception as exception:
            self.output_queue.put({
                "type": "error",
                "value": exception
            })
            print(exception)
            canceled = True

        finally:
            try:
                if canceled:
                    ars.output_queue.put({
                        "type": "update",
                        "value": "canceled"
                    })
                    if os.path.exists(output_location):
                        os.remove(output_location)

            except Exception as exception:
                self.output_queue.put({
                    "type": "error",
                    "value": exception
                })
                print(exception)

            finally:
                self.output_queue.put({
                    "type": "update",
                    "value": "thread finished"
                    })
